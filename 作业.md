<a name="e7f88bb8"></a>
# 作业1:编译Linux内核
1.进入Linux 文件夹,执行`make x86_64_defconfig`<br />![image.png](https://cdn.nlark.com/yuque/0/2024/png/2347640/1720689655761-32df72ad-f9aa-4267-acdf-f555d08891ea.png#averageHue=%233c2847&clientId=u1390f4b2-3364-4&from=paste&height=345&id=ucd4b9bc4&originHeight=517&originWidth=865&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=223899&status=done&style=none&taskId=ua67a6f48-ed87-4a9b-a3f8-10803ef7ed6&title=&width=576.6666666666666)<br />2.配置rust 支持
```shell
make LLVM=1 menuconfig
#set the following config to yes
General setup
    --->[*] Rust support
```
![image.png](https://cdn.nlark.com/yuque/0/2024/png/2347640/1720689664853-9f8783fa-74d7-44f4-afdf-1881a252e58c.png#averageHue=%23cfcecb&clientId=u1390f4b2-3364-4&from=paste&height=345&id=u22b63fc0&originHeight=517&originWidth=865&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=185980&status=done&style=none&taskId=u7b6d4ca5-2045-4588-880f-199cc1ac5ed&title=&width=576.6666666666666)<br />3.编译Linux 内核<br />![image.png](https://cdn.nlark.com/yuque/0/2024/png/2347640/1720689670381-10c547ce-8399-4cea-a5fb-c524df6dbe3e.png#averageHue=%23142f1b&clientId=u1390f4b2-3364-4&from=paste&height=289&id=u6c2c2a5c&originHeight=434&originWidth=865&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=239184&status=done&style=none&taskId=u4b9ea192-82f3-4694-ab4f-2478a9e6281&title=&width=576.6666666666666)
<a name="ZwLqQ"></a>
# 作业2：对Linux内核进行一些配置
**Q: 在该文件夹中调用make LLVM=1，该文件夹内的代码将编译成一个内核模块。请结合你学到的知识，回答以下两个问题：**<br />1、编译成内核模块，是在哪个文件中以哪条语句定义的？<br />Linux内核使用Kconfig/Kbuild 来配置和编译内核，在本题中配置文件Kbuild中`obj-m := r4l_e1000_demo.o`其中`-m`表示编译为模块。

2、该模块位于独立的文件夹内，却能编译成Linux内核模块，这叫做out-of-tree module，请分析它是如何与内核代码产生联系的？

在Makefile中通过-C指定linux内核位置，通过参数M=$(PWD)指定模块源码位置
```makefile
# SPDX-License-Identifier: GPL-2.0

KDIR ?= ../linux

default:
	$(MAKE) -C $(KDIR) M=$$PWD
```

1、从新编译Linux内核，禁用默认的C版本的e1000网卡驱动，取消勾选`Device Drivers > Network device support > Ethernet driver support > Intel devices, Intel(R) PRO/1000 Gigabit Ethernet support`<br />![2.1重新编译linux内个截图 2024-07-10 21-41-05.png](https://cdn.nlark.com/yuque/0/2024/png/2347640/1720690040655-fcdc642e-7cda-4202-86f5-3d7a03220237.png#averageHue=%23cfceca&clientId=u1390f4b2-3364-4&from=paste&height=547&id=u6f79fea8&originHeight=821&originWidth=1379&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=196567&status=done&style=none&taskId=u03383018-fa1c-4827-b27c-23a5ff7a44a&title=&width=919.3333333333334)<br />2、编译e1000网卡驱动<br />![截图 2024-07-10 20-47-28未重新编译.png](https://cdn.nlark.com/yuque/0/2024/png/2347640/1720690221916-71f87e12-7458-4fe1-b643-7c4670c552fa.png#averageHue=%23194827&clientId=u1390f4b2-3364-4&from=paste&height=545&id=ud9ddca3c&originHeight=818&originWidth=1578&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=223776&status=done&style=none&taskId=u0024d989-35de-4055-a468-8328d52caa5&title=&width=1052)<br />3、安装新驱动模块<br />3.1、启动脚本，打开qemu并安装内核模块，如下图，禁用默认e1000驱动后，`ifconfig`命令执行结果为空<br />3.2、执行`insmod r4l_e1000_demo.ko`安装e1000驱动模块。<br />3.3、执行`ip link set eth0 up`连接对应网卡。<br />![1截图 2024-07-10 22-27-28.png](https://cdn.nlark.com/yuque/0/2024/png/2347640/1720690324265-e4a9475e-1ed2-4885-9271-dbbf14d2bbed.png#averageHue=%23300a25&clientId=u1390f4b2-3364-4&from=paste&height=575&id=u8ae4871c&originHeight=863&originWidth=1403&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=191146&status=done&style=none&taskId=ud72bf611-1a07-4b57-8809-7f3fbf7752d&title=&width=935.3333333333334)<br />3.4、执行`ip addr add 10.0.2.15/255.255.255.0 brd + dev eth0 `为网卡配置ip地址和广播地址。<br />3.5、为网卡添加一条新的路由`ip route add default via 10.0.2.1`<br />3.6、`ping 10.0.2.2`结果<br />![2截图 2024-07-10 22-28-01.png](https://cdn.nlark.com/yuque/0/2024/png/2347640/1720690507788-c80cc81a-9b63-478d-b314-56f33f15a284.png#averageHue=%23300a25&clientId=u1390f4b2-3364-4&from=paste&height=575&id=ubfd35018&originHeight=863&originWidth=1403&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=192753&status=done&style=none&taskId=uec7d8e4d-c84d-476b-b94e-04f23046966&title=&width=935.3333333333334)<br />3.7、执行`ifconfig`验证<br />![4截图 2024-07-10 22-28-42.png](https://cdn.nlark.com/yuque/0/2024/png/2347640/1720690784523-d7024540-f1d9-4df2-90eb-9a5eb865ccf0.png#averageHue=%23300a24&clientId=u1390f4b2-3364-4&from=paste&height=575&id=udf451e6e&originHeight=863&originWidth=1403&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=161771&status=done&style=none&taskId=ufe74a643-0638-48f4-85ea-85ee9337e4e&title=&width=935.3333333333334)

<a name="aeOJD"></a>
#  作业 3：使用 rust 编写一个简单的内核模块并运行  
1、添加 `rust_helloworld.rs`
```rust
// SPDX-License-Identifier: GPL-2.0
//! Rust helloworld sample.

use kernel::prelude::*;

module! {
  type: RustHelloWorld,
  name: "rust_helloworld",
  author: "whocare",
  description: "hello world module in rust",
  license: "GPL",
}

struct RustHelloWorld {}

impl kernel::Module for RustHelloWorld {
    fn init(_name: &'static CStr, _module: &'static ThisModule) -> Result<Self> {
        //注意此处需要加 \n 否则不显示，怀疑是缓冲区没有flush
        pr_err!("Hello World from Rust module\n");
        Ok(RustHelloWorld {})
    }
}


```
2、在`linux/sample/rust/Kconfig`添加配置
```makefile
config SAMPLE_RUST_HELLOWORLD
	tristate "HelloWorld"
	help
	  This option builds the Rust HelloWorld module sample.

	  If unsure, say N.
```
3、在`linux/sample/rust/Makefile`添加配置
```makefile
obj-$(CONFIG_SAMPLE_RUST_HELLOWORLD)		+= rust_helloworld.o
```
4、从新编译内核
```makefile
General setup
         ---> [*] Rust support
Kernel hacking
 [*] Sample kernel code  ---> 
     [*]   Rust samples  --->  
         <M>   HelloWorld    
```
![截图 2024-07-11 19-50-33.png](https://cdn.nlark.com/yuque/0/2024/png/2347640/1720698683326-3f3dbaf4-304b-4042-9126-e0c03ebab1b4.png#averageHue=%23cfcecb&clientId=u1390f4b2-3364-4&from=paste&height=598&id=u8bf315fa&originHeight=897&originWidth=1227&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=128775&status=done&style=none&taskId=u90c014c5-2e19-478b-bfbf-4086970c289&title=&width=818)<br />5、将在`samples/rust`下看到一份`rust_helloworld.ko`的文件，将该文件复制到仓库中`src_e1000/rootfs`目录下，然后重新跑`build_image.sh`<br />![截图 2024-07-11 19-53-14.png](https://cdn.nlark.com/yuque/0/2024/png/2347640/1720698827017-77134c7f-0fc6-48ea-8a63-d783379a7787.png#averageHue=%23323231&clientId=u1390f4b2-3364-4&from=paste&height=187&id=udda512a8&originHeight=281&originWidth=949&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=54223&status=done&style=none&taskId=u782d3952-2e32-4a33-9d14-4b4e6475171&title=&width=632.6666666666666)<br />6、执行`ls`，`insmod rust_helloworld.ko`结果<br />![截图 2024-07-11 21-40-40.png](https://cdn.nlark.com/yuque/0/2024/png/2347640/1720705764622-4451260b-26af-41f7-8b9d-05d1e27edbe6.png#averageHue=%2332597d&clientId=u1390f4b2-3364-4&from=paste&height=626&id=ucecf8da5&originHeight=939&originWidth=1257&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=270064&status=done&style=none&taskId=ud26e9d5b-abd1-4658-ba9d-07f2c0c4fb0&title=&width=838)
<a name="h4zG4"></a>
# 作业4：为e1000网卡驱动添加remove代码

[参考资料 https://github.com/elliott10/e1000-driver](https://github.com/elliott10/e1000-driver)
<a name="PZU1b"></a>
# 作业5：注册字符设备
**Q：作业5中的字符设备/dev/cicv是怎么创建的？它的设备号是多少？它是如何与我们写的字符设备驱动关联上的？**<br />通过命令`mknod /dev/cicv c 248 0`可以创建一个设备文件，其中参数c表示为字符设备，248为主设备号，0为次设备号，设备驱动通过系统动态分配设备号的方式关联。

5.1 实现Read  Write 方法
```rust
    fn write(
        this: &Self,
        _file: &file::File,
        reader: &mut impl kernel::io_buffer::IoBufferReader,
        offset: u64,
    ) -> Result<usize> {
        let offset = offset.try_into()?;
        let mut vec = this.inner.lock();
        let len = core::cmp::min(reader.len(), vec.len().saturating_sub(offset));
        reader.read_slice(&mut vec[offset..][..len])?;
        Ok(len)
    }

    fn read(
        this: &Self,
        _file: &file::File,
        writer: &mut impl kernel::io_buffer::IoBufferWriter,
        offset: u64,
    ) -> Result<usize> {
        let offset = offset.try_into()?;
        let vec = this.inner.lock();
        let len = core::cmp::min(writer.len(), vec.len().saturating_sub(offset));
        writer.write_slice(&vec[offset..][..len])?;
        Ok(len)
    }
```
5.2勾选Character device，并从新编译内核
```rust
Kernel hacking
  ---> Sample Kernel code
      ---> Rust samples
              ---> <*>Character device (NEW)

```
5.3 启动qemu，并加载内核模块，向字符设备输入文字并回显。<br />![截图 2024-07-13 12-41-02.png](https://cdn.nlark.com/yuque/0/2024/png/2347640/1720845891296-ab8f9ec5-9f25-4923-b72e-e980d61615ab.png#averageHue=%23300a24&clientId=u633f0d54-df11-4&from=paste&height=511&id=u23aa263d&originHeight=767&originWidth=1197&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=145578&status=done&style=none&taskId=u365aaee5-1922-4e7e-94b7-7b8ec21beb3&title=&width=798)<br />[参考资料：Rust for Linux | 用 Rust 写 Linux 内核模块](https://mp.weixin.qq.com/s/m2eZ0lEzQHjrNVC6YCC_IA)
<a name="l6Vuh"></a>
# 实验小项目
查看002_completion下C语言版本代码，其实现了一个字符设备的驱动，主要功能包括加载/卸载，打开，读，写等功能，这与作业5的字符设备功能基本一致，因此可以复用作业5中的代码，并根据实验要求修改部分代码。

1、根据文档配置相关环境，相关配置位于r4l_experiment，具体配置文件见代码提交。<br />2、使用rust重构C版本代码，编译，加载模块驱动，具体见代码提交。<br />3、打开qemu，加载驱动，根据test the module实验步骤开启两个console，其中一个读另一个写，观察结果。<br />![截图 2024-07-14 19-14-56.png](https://cdn.nlark.com/yuque/0/2024/png/2347640/1720955735278-64994a48-8ad6-4a57-bb2c-ea7ff0b06ce6.png#averageHue=%23340b28&clientId=uf34d31ba-fc26-4&from=paste&height=461&id=u274808b2&originHeight=691&originWidth=1481&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=155182&status=done&style=none&taskId=uf5e43131-3543-4169-abf3-7456c2f05fd&title=&width=987.3333333333334)
